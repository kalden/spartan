#' Generates parameter/measure plot for each pairing in the analysis
#'
#' Produces a graph for each parameter, and each output measure, showing
#' the simulation output achieved when that parameter was assigned that value.
#' Eases identification of any non-linear effects.
#'
#' @inheritParams lhc_generateLHCSummary
#' @param parameters Array containing the names of the parameters of which
#' parameter samples will be generated
#' @param measures Array containing the names of the output measures which are
#' used to analyse the simulation
#' @param MEASURE_SCALE Scale in which each of the output responses is
#' measured. Used to label plots
#' @param corcoeffs_outputfile File produced by spartan containing the Partial
#' Rank Correlation Coefficients for each parameter/measure pairing
#' @param lhcsummary_filename Name of the LHC Summary file to be generated.
#' Contains each parameter set alongside the result gained when the simulation
#' was run under that criteria.
#' @param OUTPUT_TYPE Type of graph to plot. Can be PDF, PNG, TIFF, BMP, etc,
#'  all formats supported by ggplot2
#' @param GRAPHTIME The timepoint being processed, if any. NULL if not.
#' @param check_done For multiple timepoints, whether input has been checked
#' @param corcoeffs_output_object Correlation coefficients can be input as an
#' R object as well as CSV file. In this case, CORCOEFFSOUTPUTFILE will be NULL
#' @param lhc_summary_object If not specified in a CSV file, results can be specified in an
#' R object. In this case LHCSUMMARYFILENAME will be NULL
#'
#' @importFrom purrr walk
#' @importFrom dplyr as_data_frame
#' @export
#'
lhc_graphMeasuresForParameterChange <-
  function(FILEPATH, parameters, measures, MEASURE_SCALE, corcoeffs_outputfile,
           lhcsummary_filename, OUTPUT_TYPE = c("PDF"), TIMEPOINTS = NULL,
           TIMEPOINTSCALE = NULL, GRAPHTIME = NULL, check_done=FALSE,
           corcoeffs_output_object=NULL, lhc_summary_object=NULL) {

  # Spartan 4 method - removes all for loops and uses tidyverse to produce plots
  if(is.null(TIMEPOINTS)) {
    # get the simulation response data
    lhcresult <- get_lhc_summary_data(FILEPATH, lhcsummary_filename, lhc_summary_object)
    # Get data into format where each parameter value is paired with responses
    graph_data<-lapply(lhcresult[parameters], function(x,y){dplyr::bind_cols(as_data_frame(x),as_data_frame(y))}, lhcresult[measures])

    # get the correlation coefficients for including on the plot
    cor_coefficients <- get_correlation_stat_data(FILEPATH,corcoeffs_outputfile, corcoeffs_output_object)

    # Now we can make the plot pairings
    walk(measures,iterate_results_for_plotting, graph_data, parameters, cor_coefficients, output_types = OUTPUT_TYPE, GRAPHTIME, FILEPATH)

  } else  {

    lhc_graphMeasuresForParameterChange_overTime(
      FILEPATH, parameters, measures, MEASURE_SCALE, corcoeffs_outputfile,
      lhcsummary_filename, OUTPUT_TYPE, TIMEPOINTS,
      TIMEPOINTSCALE, GRAPHTIME)

  }
}

#' Function used by walk to create plots for all measure and response pairs
#' @param measure Simulation measure being examined
#' @param data_to_plot Data to plot for all parameters for this measure
#' @param parameters Simulation parameters being analysed
#' @param coefficients Calculated coefficient values for this analysis
#' @param output_types File types of graphs to produce
#' @param graph_time If multiple timepoints, the timepoint being plotted
#' @param filepath The directory where the graphs are to be saved to
iterate_results_for_plotting <- function(measure, data_to_plot, parameters, coefficients, output_types, graph_time, filepath)
{
  message(paste0("Producing plots for response ",measure))
  purrr::pwalk(list(param_data=data_to_plot, parameter= parameters, coefficient=coefficients[paste0(measure,".estimate"),]),make_lhc_plot, measure, graph_time, graph_format=output_types, filepath)
}

#' Retrieve the simulation summary data to plot
#' @param FILEPATH Root path of the analysis being performed (this may be deleted)
#' @param lhcsummary_filename Path to the the file containing this data, or NULL
#' @param lhcsummary_object Name of the R object containing this data, or NULL
#' @return Data for processing in the plots
get_lhc_summary_data<-function(FILEPATH, lhcsummary_filename, lhcsummary_object) {
  if(!is.null(lhcsummary_filename))
    return(read_from_csv(file.path(FILEPATH, lhcsummary_filename)))
  else if(!is.null(lhcsummary_object))
    return(lhcsummary_object)
}

#' Retrieve the correlation stats data to plot
#'
#' @param FILEPATH Root path of the analysis being performed (this may be deleted)
#' @param corcoeffs_outputfile Path to the the file containing this data, or NULL
#' @param corcoeffs_outputobject Name of the R object containing this data, or NULL
#' @return Data for processing in the plots
#' @importFrom tibble column_to_rownames
get_correlation_stat_data<-function(FILEPATH, corcoeffs_outputfile, corcoeffs_outputobject) {

  if(!is.null(corcoeffs_outputfile))
    return(column_to_rownames(read_from_csv(file.path(FILEPATH,corcoeffs_outputfile)), var = "X1"))
  else if(!is.null(corcoeffs_outputobject))
    return(corcoeffs_outputobject)
}

#' Uses ggplot2 to create a plot for the LHC analysis, for one parameter-measure pair
#'
#' @param param_data List of parameter value against simulation responses
#' @param parameter Name of the parameter being plotted
#' @param coefficient Coefficient value for this parameter measure pairing
#' @param measure Name of the measure being plotted
#' @param graph_time If plotting multiple timepoints, the timepoint being plotted
#' @param graph_format Output formats to produce. Defaults to PDF
#' @param filepath The directory where the graphs are to be stored
#'
#' @importFrom purrr walk
#' @importFrom ggplot2 aes_
#'
make_lhc_plot <- function(param_data, parameter, coefficient, measure, graph_time, graph_format=c("PDF"), filepath) {

  # Check coefficient isn't NA
  if(!is.na(coefficient)) {

    timepoint_append_string <- ""
    if(!is.null(graph_time))
      timepoint_append_string <- paste0("\nTimepoint: ",graph_time)

    output_graph <- ggplot(param_data,
                           aes_(x = ~ value,
                               y = as.vector(param_data[[measure]]))) +
      geom_point(size = 0.5) +
      scale_y_continuous(limits = c(
        floor(min(as.numeric(param_data[[measure]]))), ceiling(max(as.numeric(param_data[[measure]]))))) +
      labs(x = "Parameter Value", y = "Simulation Response",
           title = paste0("LHC Analysis for Parameter: ",parameter),
           subtitle = paste("Measure: ",measure, "\nCorrelation Coefficient: ", toString(signif(coefficient, 3)),timepoint_append_string)) +
      theme(axis.title = element_text(size = 7),
            axis.text = element_text(size = 7),
            plot.title = element_text(size = 9, hjust = 0.5),
            plot.subtitle = element_text(size = 8, hjust = 0.5))

    # Save the plot in the desired formats
    walk(as.list(graph_format),save_graph_in_desired_formats,paste0(parameter,"_",measure,graph_time),output_graph, filepath)

  } else {
    message(paste0("For Parameter ",parameter, " Measure ",measure, " Pairing, Correlation Coefficient was reported as NA. Excluded from plotting."))
  }
}

#' Saves a ggplot graph in the desired format. Used by walk functions in spartan
#'
#' @param output_type Type of graph to be produced
#' @param graph_file File name to give the graph
#' @param output_graph ggplot2 graph object
#' @param filepath The directory where the graphs are to be stored
save_graph_in_desired_formats <-function(output_type, graph_file, output_graph, filepath) {

  if (output_type == "PDF") {
    ggsave(file.path(filepath,paste0(graph_file, ".pdf")), plot = output_graph, width = 4, height = 4)
  } else if (output_type == "PNG") {
    ggsave(file.path(filepath,paste0(graph_file, ".png")),
           plot = output_graph, width = 4, height = 4)
  } else if (output_type == "TIFF") {
    ggsave(file.path(filepath,paste0(graph_file, ".tiff")),
           plot = output_graph, width = 4, height = 4)
  } else if (output_type == "BMP") {
    ggsave(file.path(filepath,paste0(graph_file, ".bmp")),
           plot = output_graph, width = 4, height = 4)
  }
}

#' Generates parameter/measure plot for each pairing in the analysis, from results stored in a database
#'
#' Produces a graph for each parameter, and each output measure, showing
#' the simulation output achieved when that parameter was assigned that value.
#' Eases identification of any non-linear effects. This method uses simulation
#' results stored in a database by spartanDB
#'
#' @param db_results Results for a specified experiment mined from the database
#' @param corcoeffs Correlation coefficients calculated for those results,
#' held in the databae
#' @param parameters Parameters included in this analysis
#' @param measures Simulation output measures
#' @param MEASURE_SCALE Scale in which each of the output responses is
#' measured. Used to label plots
#' @param output_directory Folder where the graphs should be stored
#' @param OUTPUT_TYPE Type of graph to plot. Can be PDF, PNG, TIFF, BMP, etc,
#'  all formats supported by ggplot2
#'
#' @export
#'
lhc_graphMeasuresForParameterChange_from_db <-
  function(db_results, corcoeffs, parameters, measures, MEASURE_SCALE, output_directory,
           OUTPUT_TYPE = c("PDF")) {

  message ("Generating output graphs for LHC Parameter Analysis")

  # CREATE A GRAPH FOR EACH PARAMETER, FOR EACH MEASURE
  for (p in 1:length(parameters)) {
    for (m in 1:length(measures)) {

      # Get the PRCC value for this pairing
      #corr_result <- subset(corcoeffs, corcoeffs$parameter==parameters[p] & corcoeffs$measure==measures[m],select=c(statistic_1))
      corr_result <- corcoeffs[corcoeffs$parameter == parameters[p] & corcoeffs$measure == measures[m],]["statistic_1"]

      # Make filename, titles, and labels
      titles <- make_graph_title(output_directory, parameters[p], NULL, measures[m],
                                 MEASURE_SCALE[m],as.numeric(corr_result), NULL)

      # Filter the data to plot
      data_to_plot <- data.frame(as.numeric(db_results[, parameters[p]]),
                                 as.numeric(db_results[, measures[m]]))

      # Create graphs
      output_ggplot_graph(titles$file, OUTPUT_TYPE,
                          make_lhc_plot(data_to_plot, titles))
    }
  }
  message("LHC Graphs Complete")
}

#' Wrapper for graphing LHC results for multiple timepoints
#' @inheritParams lhc_graphMeasuresForParameterChange
lhc_graphMeasuresForParameterChange_overTime <-
    function(FILEPATH, parameters, measures, MEASURE_SCALE, corcoeffs_outputfile,
             lhcsummary_filename, OUTPUT_TYPE = c("PDF"), TIMEPOINTS = NULL,
             TIMEPOINTSCALE = NULL, GRAPHTIME = NULL) {

      for (n in 1:length(TIMEPOINTS)) {
        current_time <- TIMEPOINTS[n]
        message(paste("Processing Timepoint: ", current_time, sep = ""))

        corcoeffs_output_full <- append_time_to_argument(
          corcoeffs_outputfile, current_time,
          check_file_extension(corcoeffs_outputfile))

        lhcsummary_full <- append_time_to_argument(
          lhcsummary_filename, current_time,
          check_file_extension(lhcsummary_filename))

        lhc_graphMeasuresForParameterChange(
          FILEPATH, parameters, measures, MEASURE_SCALE, corcoeffs_output_full,
          lhcsummary_full, TIMEPOINTS = NULL, TIMEPOINTSCALE = TIMEPOINTSCALE,
          GRAPHTIME = current_time, check_done = TRUE)

      }
    }

## NO LONGER USED IN SPARTAN 4, BUT KEPT SO TIMEPOINTS CAN BE EXAMINED
# Make graph title, sub title, and file name
# @param filepath Directory to output graph to
# @param parameter Current parameter being processed
# @param graph_time Timepoint, if multiple timepoints
# @param measure Current measure being processed
# @param measure_scale Scale of the measure being processed
# @param corr_stat The PRCC for this parameter-measure pair
# @param timepointscale Scale of timepoints, if multiple
# @return List containing file, title, and subtitle, and axes labels
make_graph_title <- function(filepath, parameter, graph_time, measure,
                             measure_scale, corr_stat, timepointscale) {
  graph_title <- paste("LHC Analysis for Parameter: ",parameter, sep = "")
  y_label <- paste("Median Value Across Runs (", measure_scale,
                   ")", sep = "")
  x_label <- "Parameter Value"

  if (is.null(graph_time)) {
    graph_file <- file.path(filepath,paste(parameter,measure,sep="_"))
    sub_title <- paste("Measure: ",measure,"\nCorrelation Coefficient: ",
                      toString(signif(corr_stat, 3)), sep = "")
  } else {
    graph_file <- file.path(filepath,paste(parameter, measure, graph_time,
                                           sep="_"))
    sub_title <- paste(
      "Measure: ",measure, ". Timepoint: ", graph_time, " ", timepointscale,
      "\nCorrelation Coefficient: ", toString(signif(corr_stat, 3)), sep = "")
  }
  return(list("title"=graph_title,"file"=graph_file,"sub_title"=sub_title,
         "xlabel"=x_label,"ylabel"=y_label))
}

## REPLACED IN SPARTAN4
#' Make the LHC output plot
# @param data_to_plot Parameter and measure pair data
# @param titles Object containing graph title and subtitle
# @return Created graph object
#make_lhc_plot <- function(data_to_plot, titles) {
#  output_graph <- ggplot(data_to_plot,
#                         aes(x = data_to_plot[, 1],
#                             y = data_to_plot[, 2])) +
#    geom_point(size = 0.5) +
#    scale_y_continuous(limits = c(
#      floor(min(as.numeric(data_to_plot[,2]))), ceiling(max(as.numeric(data_to_plot[, 2]))))) +
#    labs(x = titles$xlabel, y = titles$ylabel,
#         title = titles$title, subtitle = titles$sub_title) +
#    theme(axis.title = element_text(size = 7),
#          axis.text = element_text(size = 7),
#          plot.title = element_text(size = 9, hjust = 0.5),
#          plot.subtitle = element_text(size = 8, hjust = 0.5))
#
#  return(output_graph)
#}

#' Deprecated. Use \code{lhc_graphMeasuresForParameterChange} instead
#'
#' @inheritParams lhc_graphMeasuresForParameterChange
lhc_netlogo_graphMeasuresForParameterChange <- function(FILEPATH, parameters,
                                                        measures,
                                                        MEASURE_SCALE,
                                                        corcoeffs_outputfile,
                                                        lhcsummary_filename,
                                                        TIMEPOINTS,
                                                        TIMEPOINTSCALE) {

  message("Deprecated. Use the lhc_graphMeasuresForParameterChange method instead")
}

#' Creates a polar plot for each response, showing PRCC for each parameter
#'
#' Added in Spartan 3.0. Provides a means of plotting the partial rank
#' correlation coefficients as a polar plot, to ease comparison of these values.
#'
#' @inheritParams lhc_graphMeasuresForParameterChange
#' @param corcoeffs_outputfile If in a CSV file, the calculated PRCC values
#' @param corcoeffs_outputobject If in an R object, the calculated PRCC values
#' @export
#'
#' @import plotrix
lhc_polarplot <- function(FILEPATH, parameters, measures, corcoeffs_outputfile=NULL,
                          corcoeffs_outputobject = NULL, TIMEPOINTS = NULL,
                          TIMEPOINTSCALE = NULL) {

  # Produce a polar plot that shows all the PRCCs for the PARAMETERS
  # in a latin-hypercube analysis
  if (is.null(TIMEPOINTS) || length(TIMEPOINTS) == 1) {
    # Check the FILEPATH exists
    if (file.exists(FILEPATH)) {
      # Check the coefficient file exists

        # Read in the file
        CORCOEFFS <- get_correlation_stat_data(FILEPATH, corcoeffs_outputfile, corcoeffs_outputobject)

        #CORCOEFFS <- read.csv(paste(FILEPATH, "/", CORCOEFFSOUTPUTFILE,
        #                            sep = ""),
        #                      header = TRUE, check.names = FALSE,
        #                      row.names = 1)



        # Plot set up:
        # convert 360 degrees to radians
        circle_in_radians <- 6.28319

        # outputs:
        output_forms <- c("png", "pdf")

        # Now create a plot for all simulation MEASURES
        for (m in 1:length(measures)) {

          # Need to exclude any parameters that are NA prior to plotting
          #na_corrs <- which(is.na(CORCOEFFS[,paste0(MEASURES[m],"_Estimate")]))
          na_corrs <- which(is.na(CORCOEFFS[paste0(measures[m],".estimate"),]))

          plot_parameters<-parameters
          if(length(na_corrs)>0)
          {
            plot_parameters<-parameters[!(parameters %in% parameters[na_corrs])]
            message(paste0("For Measure ",measures[m],", Parameter(s) ",toString(parameters[na_corrs])," reported correlation coefficients of NA. Excluded from Plot. Check calculation"))
          }

          # Check there are still parameters left to plot after those removed!
          if(length(plot_parameters)>0)
          {

            degree <- circle_in_radians / length(plot_parameters)

            # Create the angles at which the PARAMETERS will be shown on the
            # plot, as well as the colours (blue negative, red positive)
            angle <- c()
            colours <- c()

            for (i in 1:length(plot_parameters))
            {
              angle <- c(angle, degree * i)
              # Now see if the correlation is positive or negative

              if (CORCOEFFS[paste0(measures[m],".estimate"),plot_parameters[i]] < 0)
              {
                  colours <- c(colours, "blue")
              } else {
                  colours <- c(colours, "red")
              }
            }

            graph_name <- paste(FILEPATH, "/polarPlot_", measures[m],sep="")
            if(!is.null(TIMEPOINTS))
              graph_name<-paste(graph_name,"_",TIMEPOINTS,sep="")

            # Now plot the graph:
            for (o in 1:length(output_forms))  {
              if (output_forms[o] == "pdf")
                pdf(paste(graph_name, ".pdf", sep = ""), width = 12)
              if (output_forms[o] == "png")
                png(filename = paste(graph_name,".png",sep = ""), width = 800)

              # Sets the size of the labels on the outside of the polar plot

              par(cex.axis = 1.5)

              # readjust the parameter list to align with the correct angles
              PARAM_NAMES <- c(plot_parameters[length(plot_parameters)],
                               plot_parameters[1:length(plot_parameters) - 1])


              # Note we use absolute values as plot goes from 0 to 1, it is the
              # colour which shows if it is positive or negative
              radial.plot(abs(CORCOEFFS[paste0(measures[m],".estimate"),plot_parameters]),
                          angle, rp.type = "r",
                          lwd = 4, line.col = colours,
                          labels = seq(1, length(plot_parameters), by = 1),
                          radial.lim = c(0, 1), #range of grid circle
                          main = paste("Partial Rank Correlation Coefficient Values for ", measures[m], sep = ""),
                          show.grid.labels = 2,
                          #put the concentric circle labels going down
                          show.radial.grid = TRUE,
                          cex.lab = 0.7,
                          clockwise=FALSE,
                          mar=c(2.1,1.1,4.1,2.1)
              )

              legend(-1.7,1, c("Positive", "Negative"), lty = 1, lwd = 1:2,
                     col = c("red", "blue"), cex = 1.1, pt.cex = 1)
              par(xpd = TRUE)
              #legend(1.5, 1, pch = as.character(c(1:length(plot_parameters))),
              #       PARAM_NAMES, cex = 0.7, pt.cex = 0.5)
              param_legend<-paste(1:length(PARAM_NAMES),PARAM_NAMES)
              legend(1.5, 1, pch = "",
                     legend=param_legend, cex = 0.8, pt.cex = 0.8)
              par(xpd = FALSE)
              dev.off()
            }
          }
        }
    }
  } else {
    # PROCESS EACH TIMEPOINT, AMENDING FILENAMES AND RECALLING THIS FUNCTION
    for (n in 1:length(TIMEPOINTS)) {
      current_time <- TIMEPOINTS[n]
      message(paste("Processing Timepoint: ", current_time, sep = ""))

      CORCOEFFSOUTPUTFILE_FORMAT <- check_file_extension(corcoeffs_outputfile)
      CORCOEFFSOUTPUTFILE_FULL <- paste(substr(corcoeffs_outputfile, 0,
                                               nchar(corcoeffs_outputfile) - 4),
                                        "_", current_time, ".",
                                        CORCOEFFSOUTPUTFILE_FORMAT, sep = "")

      lhc_polarplot(FILEPATH, parameters, measures, CORCOEFFSOUTPUTFILE_FULL,
                    TIMEPOINTS = current_time,
                    TIMEPOINTSCALE = TIMEPOINTSCALE)
    }
  }
}


#' Plots Graphs for Partial Rank Correlation Coefficients Over Time
#'
#' Produces plots to show how the impact of a parameter changes over time,
#' measured by the change in PRCC
#'
#' @inheritParams lhc_graphMeasuresForParameterChange
#' @param CORCOEFFSFILENAME Name of the CSV file containining the correlation
#' coefficients
#'
#' @export
#' @importFrom grDevices png
plotPRCCSFromTimepointFiles <- function(FILEPATH, parameters, measures,
                                      CORCOEFFSFILENAME, TIMEPOINTS,
                                      TIMEPOINTSCALE) {
  message("Plotting Graphs for Partial Rank Correlation Coefficients Over Time")

    # One plot for each parameter
    for (PARAM in 1:length(parameters)) {
      # PRCCS for this parameter
      FULLPARAMRESULTS <- NULL
      # measures excluded as NA
      measures_excluded<-NULL

      # Now to gather the data for each hour from the relevant result files
      for (i in 1:length(TIMEPOINTS)) {

        hour <- TIMEPOINTS[i]

        # Add the timepoint to the correlation coefficient results file
        CORCOEFFSOUTPUTFILE_FORMAT <- check_file_extension(CORCOEFFSFILENAME)
        CORCOEFFSOUTPUTFILE_FULL <- paste(substr(CORCOEFFSFILENAME, 0,
                                                 nchar(CORCOEFFSFILENAME) - 4),
                                          "_", hour, ".",
                                          CORCOEFFSOUTPUTFILE_FORMAT, sep = "")


        # Read in the coefficients
        LHCResults <- read_from_csv(file.path(FILEPATH,CORCOEFFSOUTPUTFILE_FULL))

        results<-NULL

        for(m in 1:length(measures)) {
          # Get the PRCCS
          results <- rbind(results,cbind(hour, measures[m],LHCResults[PARAM, paste0(measures[m],"_Estimate")]))

          # Exclude measure if NA or Inf
          if((is.na(LHCResults[PARAM, paste0(measures[m],"_Estimate")]) | LHCResults[PARAM, paste0(measures[m],"_Estimate")]==Inf)  & !measures[m] %in% measures_excluded) {
            measures_excluded <- c(measures_excluded,measures[m])
          }

        }


        # Append the PRCCS for this timepoint to those of all timepoints
        FULLPARAMRESULTS <- rbind(FULLPARAMRESULTS, results)
      }

      colnames(FULLPARAMRESULTS)<-c("hour","measure","prcc")
      FULLPARAMRESULTS<-as_data_frame(FULLPARAMRESULTS)
      FULLPARAMRESULTS$prcc<-as.numeric(FULLPARAMRESULTS$prcc)
      FULLPARAMRESULTS$hour<-as.factor(FULLPARAMRESULTS$hour)
      FULLPARAMRESULTS$measure<-as.factor(FULLPARAMRESULTS$measure)

      prcc_time_plot<-ggplot(filter(FULLPARAMRESULTS, !FULLPARAMRESULTS$measure %in% measures_excluded),aes(x=FULLPARAMRESULTS$hour,y=FULLPARAMRESULTS$prcc,group=FULLPARAMRESULTS$measure)) +
        ggplot2::geom_line(aes(linetype=FULLPARAMRESULTS$measure,col=FULLPARAMRESULTS$measure)) +
        scale_y_continuous(limits=c(-1,1),name="Partial Rank Correlation Coefficient") +
        labs(title = "PRCC Values Over Simulation Time",
             subtitle = paste0("Parameter: ",parameters[PARAM]),
             x =paste0("Timepoint (",TIMEPOINTSCALE,")")) +
        theme(plot.title = element_text(size=9,hjust=0.5),plot.subtitle = element_text(size=8,hjust=0.5),
              axis.text.x = element_text(size=8),axis.text.y = element_text(size=8), axis.title=element_text(size=8), legend.title=element_text(size=8),
              legend.text = element_text(size=6))

            if(length(measures_excluded)>0)
        message(paste0("For parameter ",parameters[PARAM], "the following measures had a PRCC value of NA or Inf, and were excluded from the plot: ",measures_excluded))

      #ggsave(filename=paste0(FILEPATH,parameters[PARAM],"_PRCC_OverTime.pdf"),plot=prcc_time_plot,device="pdf")

  }
    message(paste("Complete. Check for output in the directory ", FILEPATH,
                sep = ""))
}


# TO BE REMOVED FROM SPARTAN4 - NEEDS A REWRITE
# Plots the PRCC coefficients against each other for ease of comparison
#
# Plots the Partial Rank Correlation Coefficients for either all measures
# or for one individual measure, for all simulation parameters.
#
# @param FILEPATH Location of the LHC result set
# @param CORCOEFFSOUTPUTFILE Name of the CSV file in FILEPATH containing
# the Partial Rank Correlation Coefficients
# @param MEASURES Names of the simulation responses
# @param PRINTOPT Used in plotting Partial Rank Correlation Coefficients,
# should be either "ALL" or "INDIVIDUAL"
# @param TIMEPOINTS Implemented so this method can be used when analysing
# multiple simulation timepoints. If only analysing one timepoint, this
# should be set to NULL. If not, this should be an array of timepoints,
# e.g. c(12,36,48,60)
# @param TIMEPOINTSCALE Implemented so this method can be used when
# analysing multiple simulation timepoints. Sets the scale of the timepoints
# being analysed, e.g. "Hours"
#
# @export
#
# @importFrom graphics barplot
#lhc_plotCoEfficients <- function(FILEPATH, corcoeffs_outputfile, MEASURES,
#                                 PRINTOPT, TIMEPOINTS = NULL,
#                                 TIMEPOINTSCALE = NULL) {

#  if (is.null(TIMEPOINTS) || length(TIMEPOINTS) == 1) {
#    if (file.exists(FILEPATH)) {

# COLUMN 1 HAS PARAMETER NAMES, THEN FOLLOWS FOR EACH MEASURE -
# THE PRCC AND THE P VALUE
# WE'RE GOING TO GRAPH ALL THE PRCC'S ON ONE GRAPH

#      CORCOEFFS <- get_correlation_stat_data(FILEPATH, corcoeffs_outputfile, NULL)

#      if (PRINTOPT == "INDIVIDUAL") {
# INDIVIDUAL PLOTS FOR EACH MEASURE
#        message("Producing Partial Rank Correlation Coefficient Plots for each measure")

#        for (i in 1:length(MEASURES)) {
#          if (is.null(TIMEPOINTS)) {
#            GRAPHFILE <- paste(FILEPATH, "/PRCC_Measure_", MEASURES[i], ".pdf",
#                               sep = "")
#            GRAPHTITLE <- paste("PRCC Values for Measure: ", MEASURES[i],
#                                sep = "")
#          } else {
#            GRAPHFILE <- paste(FILEPATH, "/PRCC_Measure_", MEASURES[i], "_",
#                               TIMEPOINTS, ".pdf", sep = "")
#            GRAPHTITLE <- paste("PRCC Values for Measure: ", MEASURES[i],
#                                "\nTimepoint: ", TIMEPOINTS, sep = "")
#          }

#          pdf(GRAPHFILE, width = 9, height = 5)
#          par(xpd = NA, mar = c(2, 4, 2, 17))

# Generate the heading of the CSV file - the measure plus _Estimate
#          M <- paste(MEASURES[i], "_Estimate", sep = "")
# We can now use this to get the column out the dataset

#          barplot(COEFFS[, M], ylim = c(-1, 1), col = "black",
#                  main = GRAPHTITLE,
#                  ylab = "Partial Rank Correlation Coefficient",
#                  names.arg = seq(1, nrow(COEFFS), by = 1))

#          thelabels <- paste(1:nrow(COEFFS), " ", COEFFS[, 1], sep = "")
#          par(xpd = TRUE)
#          legend_size <- nrow(COEFFS) + 1.5
#          legend(legend_size, 1.0, legend = thelabels, pch = "",
#                 cex = 0.6, ncol = 1)
#          par(xpd = FALSE)
#          dev.off()
#        }

#      } else if (PRINTOPT == "ALL") {
#        message("Producing Partial Rank Correlation Coefficient Summary Plot of All Measures")

# ALL PRCCS FOR ALL MEASURES, ON ONE PLOT
# Make the data frame for the plot
# FIRST OF ALL WE NEED TO REMOVE THE P VALUES SO WE CAN AUTOMATE THIS

#       if (is.null(TIMEPOINTS)) {
#          GRAPHFILE <- paste(FILEPATH, "/PRCC_AllMeasures.pdf", sep = "")
#          GRAPHTITLE <- "PRCC Values for All Measures"
#        } else {
#          GRAPHFILE <- paste(FILEPATH, "/PRCC_AllMeasures_", TIMEPOINTS,
#                             ".pdf", sep = "")
#          GRAPHTITLE <- paste("PRCC Values for All Measures\nTimepoint: ",
#                              TIMEPOINTS, sep = "")
#        }

#        pdf(GRAPHFILE, width = 10, height = 5)

#        par(xpd = NA, mar = c(2, 4, 2, 9))

#        PRCCS <- NULL
#        for (p in seq(2, ncol(COEFFS), by = 2)) {
#          PRCCS <- cbind(PRCCS, COEFFS[, p])
#        }

# NOW MAKE THE DATA FRAME
#        d <- data.frame(row.names = levels(COEFFS[, 1]), PRCCS,
#                        check.names = FALSE)
#        colnames(d) <- MEASURES
#        d <- do.call(rbind, d)
#        barplot(d, beside = TRUE, ylim = c(-1, 1.4),
#                legend.text = rownames(d),
#                args.legend = list(x = "topright", bty = "n"),
#                names.arg = seq(1, nrow(COEFFS), by = 1),
#                main = GRAPHTITLE,
#                ylab = "Partial Rank Correlation Coefficient")

#        thelabels <- paste(1:nrow(COEFFS), " ", COEFFS[, 1], sep = "")
#        par(xpd = TRUE)
#        legend_size <- nrow(COEFFS)*3
#legend(legend_size, 1.0, legend = thelabels, pch = "",
#       cex = 0.7, ncol = 1)
#        legend("topright", inset=c(-0.2,0), 1.0, legend = thelabels, pch = "",
#               cex = 0.7, ncol = 1)

#        par(xpd = FALSE)
#        dev.off()
#      }
#    }
#  } else {
# PROCESS EACH TIMEPOINT, AMENDING THE FILENAMES, RECALLING THIS FUNCTION
#    for (n in 1:length(TIMEPOINTS)) {

#      current_time <- TIMEPOINTS[n]
#      message(paste("Processing Timepoint ", current_time, sep = ""))

#      CORCOEFFSOUTPUTFILE_FORMAT <- check_file_extension(CORCOEFFSOUTPUTFILE)
#      CORCOEFFSOUTPUTFILE_FULL <- paste(substr(CORCOEFFSOUTPUTFILE, 0,
#                                               nchar(CORCOEFFSOUTPUTFILE) - 4),
#                                        "_", current_time, ".",
#                                        CORCOEFFSOUTPUTFILE_FORMAT, sep = "")

#      lhc_plotCoEfficients(FILEPATH, CORCOEFFSOUTPUTFILE_FULL, MEASURES,
#                           PRINTOPT, current_time, NULL)
#    }
#  }
#}
